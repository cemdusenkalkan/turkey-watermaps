<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Turkey Water Risk Atlas</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        #map {
            height: 100vh;
            width: 100vw;
        }

        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            min-width: 200px;
        }

        #controls h3 {
            margin-top: 0;
            color: #333;
        }

        select, button {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .legend {
            background: white;
            padding: 10px;
            line-height: 18px;
            border-radius: 4px;
            font-size: 12px;
        }

        .legend i {
            width: 18px;
            height: 12px;
            float: left;
            margin-right: 8px;
            opacity: 0.8;
        }

        .prov-label {
            background: none;
            border: none;
            color: #444;
            font-weight: 600;
            text-shadow: 0 0 4px #fff;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="controls">
        <h3>Turkey Water Risk Atlas</h3>
        <div id="status" style="font-size: 11px; margin: 5px 0; padding: 5px; background: #f0f0f0; border-radius: 3px;">
            Loading map data...
        </div>

        <div style="margin: 10px 0;">
            <label style="font-size: 12px; font-weight: bold;">Water Risk Metric:</label><br>
            <select id="metricSelect" style="margin-top: 3px;">
                <option value="bws">Baseline Water Stress</option>
                <option value="iav">Interannual Variability</option>
                <option value="sev">Seasonal Variability</option>
                <option value="gtd">Groundwater Table Decline</option>
                <option value="drr">Drought Risk</option>
            </select>
        </div>

        <div style="margin: 10px 0;">
            <label style="font-size: 12px; font-weight: bold;">Basemap:</label><br>
            <select id="basemapSelect" style="margin-top: 3px;">
                <option value="osm">OpenStreetMap (Detailed)</option>
                <option value="carto">CARTO (Clean)</option>
                <option value="satellite">Satellite</option>
            </select>
        </div>
    </div>

    <div id="map"></div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.vectorgrid@1.3.0/dist/Leaflet.VectorGrid.bundled.js"></script>

    <script>
        // Initialize map with Turkey bounds
        const turkeyBounds = L.latLngBounds([35, 25], [43, 46]); // SW to NE
        const map = L.map('map', {
            center: [39, 35.5],
            zoom: 6,
            maxZoom: 18,
            minZoom: 5
        });

        // Basemap layers
        const basemaps = {
            osm: L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
                maxZoom: 18,
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }),
            carto: L.tileLayer("https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png", {
                maxZoom: 18,
                attribution: '&copy; CARTO'
            }),
            satellite: L.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}", {
                maxZoom: 18,
                attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
            })
        };

        // Start with OpenStreetMap (detailed)
        let currentBasemap = basemaps.osm.addTo(map);

        // Risk color function (WRI 5-class palette)
        function riskColor(value) {
            if (value == null || isNaN(value)) return "#f7f7f7";
            if (value < 1) return "#ffffcc"; // low
            if (value < 2) return "#ffeda0"; // low-medium
            if (value < 3) return "#feb24c"; // medium-high
            if (value < 4) return "#f03b20"; // high
            return "#bd0026"; // extremely high
        }

        const TILE_LAYER_ID = "aqueduct_baseline_annual_tr_web"; // from metadata.json
        let selectedMetric = "bws";

        function metricField() {
            return selectedMetric + "_score";
        }

        function styleForProps(props) {
            const field = metricField();
            const v = props[field];
            const color = riskColor(v);

            // Debug logging
            if (Math.random() < 0.1) { // Log 10% of tiles
                console.log(`üé® Styling tile: ${field}=${v} ‚Üí color=${color}`, props);
                console.log('Available fields:', Object.keys(props));
            }

            // TEST: Force all tiles to be visible with different colors based on data presence
            let testColor = '#ff0000'; // Red = no data
            if (v !== undefined && v !== null && !isNaN(v)) {
                testColor = '#00ff00'; // Green = has data
                if (v > 2) testColor = '#0000ff'; // Blue = high values
            }

            return {
                fill: true,
                fillColor: testColor,
                fillOpacity: 0.9, // Very visible
                weight: 2, // Thick border
                color: '#000000', // Black border
                opacity: 1.0
            };
        }

        // TEST: Load GeoJSON instead of tiles to prove styling works
        let catchmentLayer = null;
        fetch("data_web/test_catchments.geojson")
            .then(r => r.json())
            .then(geo => {
                console.log('‚úÖ Test GeoJSON loaded:', geo.features.length, 'features');
                catchmentLayer = L.geoJSON(geo, {
                    style: f => styleForProps(f.properties),
                    onEachFeature: (f, layer) => {
                        const p = f.properties;
                        layer.bindPopup(
                            `<b>${p.name}</b><br>
                             BWS: ${p.bws_score?.toFixed(2)}<br>
                             IAV: ${p.iav_score?.toFixed(2)}<br>
                             SEV: ${p.sev_score?.toFixed(2)}`
                        );
                    }
                }).addTo(map);
                console.log('‚úÖ Test catchments added to map');
                document.getElementById('status').innerHTML = 'üß™ TEST MODE: GeoJSON loaded - you should see colored squares!';
                document.getElementById('status').style.background = '#d4edda';
            })
            .catch(err => {
                console.error('‚ùå Failed to load test GeoJSON:', err);
                document.getElementById('status').innerHTML = '‚ùå Test GeoJSON failed to load';
                document.getElementById('status').style.background = '#f8d7da';
            });

        // Keep vector tiles commented out for now
        /*
        const catchmentLayer = L.vectorGrid.protobuf("tiles_catchments/{z}/{x}/{y}.pbf", {
            vectorTileLayerStyles: {
                [TILE_LAYER_ID]: props => styleForProps(props)
            },
            interactive: true,
            maxZoom: 10,
            minZoom: 4,
            zIndex: 10
        }).addTo(map);
        */

        // Vector tiles commented out - using GeoJSON test instead

        // Rivers layer (zoom-controlled)
        let riversLayer;
        console.log('üåä Loading rivers data...');
        fetch("data_web/hydrorivers_tr_web_final.geojson")
            .then(r => r.json())
            .then(geo => {
                console.log(`‚úÖ Rivers loaded: ${geo.features.length} features`);
                riversLayer = L.geoJSON(geo, {
                    style: function(feature) {
                        const ord = feature.properties.ORD_STRA || 1;
                        return {
                            color: "#1f78b4",
                            weight: ord >= 6 ? 1.2 : ord >= 4 ? 0.8 : 0.4,
                            opacity: 0.5
                        };
                    }
                });

                // Add to map if already zoomed in
                if (map.getZoom() >= 7) {
                    map.addLayer(riversLayer);
                }
            })
            .catch(err => {
                console.warn("Failed to load rivers:", err);
                document.getElementById('status').innerHTML = '‚ö†Ô∏è Rivers failed to load';
            });

        // Lakes layer
        let lakesLayer;
        fetch("data_web/hydrolakes_tr_web.geojson")
            .then(r => r.json())
            .then(geo => {
                lakesLayer = L.geoJSON(geo, {
                    style: { color: "#6baed6", weight: 0.5, fillOpacity: 0.8 }
                }).addTo(map);
            })
            .catch(err => console.warn("Failed to load lakes:", err));

        // Province boundaries with labels
        fetch("data_web/turkey_provinces_web.geojson")
            .then(r => r.json())
            .then(geo => {
                L.geoJSON(geo, {
                    style: function(feature) {
                        return {
                            color: "#666",
                            weight: 1.5,
                            fillOpacity: 0,
                            dashArray: '5, 5'
                        };
                    },
                    onEachFeature: (f, layer) => {
                        layer.bindTooltip(f.properties.name, {
                            permanent: false,
                            direction: "center",
                            className: "prov-label"
                        });
                    }
                }).addTo(map);
            })
            .catch(err => console.warn("Failed to load provinces:", err));

        // Zoom control for rivers
        map.on("zoomend", () => {
            const z = map.getZoom();
            if (riversLayer) {
                if (z >= 7) {
                    if (!map.hasLayer(riversLayer)) map.addLayer(riversLayer);
                } else {
                    if (map.hasLayer(riversLayer)) map.removeLayer(riversLayer);
                }
            }
        });

        // Metric selector
        document.getElementById("metricSelect").addEventListener("change", (e) => {
            selectedMetric = e.target.value;
            console.log(`üîÑ Metric changed to: ${selectedMetric} (field: ${metricField()})`);

            // Update the GeoJSON layer style
            if (catchmentLayer) {
                catchmentLayer.setStyle(f => styleForProps(f.properties));
                console.log('‚úÖ GeoJSON style updated');
            }
        });

        // Basemap selector
        document.getElementById("basemapSelect").addEventListener("change", (e) => {
            const selectedBasemap = e.target.value;
            console.log(`üó∫Ô∏è Switching to basemap: ${selectedBasemap}`);

            // Remove current basemap
            map.removeLayer(currentBasemap);

            // Add new basemap
            currentBasemap = basemaps[selectedBasemap].addTo(map);

            console.log('‚úÖ Basemap switched');
        });

        // Popup for catchment details (GeoJSON popups are handled in layer creation above)

        // Layer controls (add after all layers are loaded)
        setTimeout(() => {
            const overlays = {
                "üü¶ Water Risk Catchments": catchmentLayer,
                "üåä Rivers (zoom ‚â•7)": riversLayer,
                "üèûÔ∏è Lakes": lakesLayer
            };

            const baseLayers = {
                "üó∫Ô∏è OpenStreetMap (Detailed)": basemaps.osm,
                "üìä CARTO (Clean)": basemaps.carto,
                "üõ∞Ô∏è Satellite": basemaps.satellite
            };

            L.control.layers(baseLayers, overlays, {
                collapsed: true,
                position: 'topright'
            }).addTo(map);
        }, 2000); // Wait for layers to load

        // Scale bar
        L.control.scale({ position: 'bottomleft', imperial: false }).addTo(map);

        // Legend
        const legend = L.control({ position: "bottomright" });
        legend.onAdd = function () {
            const div = L.DomUtil.create("div", "legend");
            div.innerHTML = '<h4 style="margin: 0 0 8px 0; font-size: 14px;">Water Risk Level</h4>';
            const grades = [0, 1, 2, 3, 4];
            const labels = ["Low (0-1)", "Low‚ÄìMed (1-2)", "Med‚ÄìHigh (2-3)", "High (3-4)", "Extremely High (4-5)"];

            for (let i = 0; i < grades.length; i++) {
                div.innerHTML +=
                    `<i style="background:${riskColor(grades[i])}"></i> ${labels[i]}<br>`;
            }

            return div;
        };
        legend.addTo(map);
    </script>
</body>
</html>